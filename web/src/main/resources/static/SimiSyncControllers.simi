import "./Stdlib/File.simi"
import "./Stdlib/Gson.simi"
import "./Stdlib/CodeBlocks.simi"
import "./SimiSyncCommons.simi"
import CodeBlocks

class_ SimiSyncControllers:

    class_ Route:
        def init(endpoint, verb): pass
    end

    class_ Request:
        def init(resourceLoaderWrapper, headers, body): @init(resourceLoaderWrapper, headers, body, nil, nil)
        def init(resourceLoaderWrapper, headers, body, query): @init(resourceLoaderWrapper, headers, body, query, nil)
        def init(resourceLoaderWrapper, headers, body, query, path): pass
    end

    class_ ClientTask:
        def init(version): pass
        def init(version, payloadVerification, headers, query, successCodes): pass
    end

    class_ Router:
        import SimiSyncCommons.Parser

        def parseControllers(version, resourceLoaderWrapper):
            @resourceLoaderWrapper = resourceLoaderWrapper
            # By convention, all controller files should live in a directory named "controller" and its subdirectories
            router = $[]
            dirPath = nil
            clientTasks = ClassComposer("ClientTasks", "$")
            for file in File.listAll("static/controllers", "simi", true, resourceLoaderWrapper):
                if not dirPath:
                    dirPath $= file.path.substring(0, file.path.lastIndexOf('/') + 1) + "clientTasks/\(version)/"
                end
                # Read and interpret the content of the file
                controllerCode = File.readString(file.path)
                controllerClass = gu @removeImports(controllerCode)
                print controllerCode
                print "AAAA"
                print @removeImports(controllerCode)
                print "BBBB"
                print controllerClass
                print "CCCCC"
                for e in controllerClass.enumerate().where(def e: e.value is Function):
                    if e.key.startsWith('_'): continue
                    value = controllerClass.(e.key)
                    route = @extractAnnot(value, SimiSyncControllers.Route)
                    if not route: continue
                    verb = route.verb
                    if verb not in router: router.(verb) = $[]
                    router.(verb).(route.endpoint) = value

                    clientTask = @extractAnnot(value, SimiSyncControllers.ClientTask)
                    if clientTask: clientTasks.add(@_getClientTask(route, clientTask))
                end
            end
            @router = router
            print router

            clientTasksCode = clientTasks.getString()
            f = File(dirPath + clientTasks.name + ".simi")
            writer = WriteStream(f)
            writer.write(clientTasksCode)
            rescue ex:
                if ex: print ex.message
                writer.close()
            end
        end

        def route(endpoint, verb, headers, query, body):
            queryObj = @_parseQuery(query)
            route = SimiSyncControllers.Route(endpoint, verb)
            print "Routing: " + route
            match = @_matchRoute(route)
            print "Found route: " + match
            simiBody = ife(body, :@_deserializeBody(body, headers), nil)
            func = ife(match is Function, :match, :match.func)
            path = ife(match is Function, nil, :match.path)
            return @_serializeResponse(func(SimiSyncControllers.Request(@resourceLoaderWrapper, headers, simiBody, queryObj, path)), headers)
        end

        def _parseQuery(query):
            if not query: return []
            queryObj = $[]
            for comp in query.split('&'):
                index = comp.indexOf('=')
                queryObj.(comp.substring(0, index)) = comp.substring(index + 1)
            end
            return queryObj
        end

        def _matchRoute(route):
            for e in @router.(route.verb).enumerate():
                [endpoint, func] = e
                path = route.endpoint
                if endpoint == path: return func
                endpointSplit = endpoint.split('/')
                pathSplit = path.split('/')
                if endpointSplit.len() != pathSplit.len(): continue

                # Check for matches amongst paths with components
                matches = true
                pathObj = $[]
                for ee in endpointSplit.enumerate():
                    [i, component] = ee
                    pathComponent = pathSplit.(i)
                    pathObj.clear()
                    if component.startsWith('$'): pathObj.(component.substring(1)) = pathComponent # Remove starting $
                    elsif component != pathComponent:
                        matches $= false
                        break
                    end
                end
                if matches: return [func = func, path = pathObj]
            end
            return nil
        end

        def _deserializeBody(body, headers):
            if @_isJson(headers): return Gson.parse(body)
            return gu body
        end

        def _serializeResponse(response, headers):
            if response is String: return response
            hasCode = response.len() == 2 and "code" in response and "body" in response
            if @_isJson(headers):
                if hasCode: return [code = response.code, \
                                    body = ife(response.body is String, :response.body, :Gson.stringify(response.body))]
                return Gson.stringify(response)
            end
            if hasCode: return response
            return ivic response
        end

        def _isJson(headers):
            contentType = headers.("content-type") ?? headers.("Content-Type")
            if contentType == "application/json": return true
            accept = headers.("accept") ?? headers.("Accept")
            return accept == "application/json"
        end

        def _getClientTask(route, clientTask):
            rawEndpoint = route.endpoint.substring(1)
            slashIndex = rawEndpoint.indexOf('/') ?? rawEndpoint.len()
            endpoint = rawEndpoint.0.upperCased() + rawEndpoint.substring(1, slashIndex)
            name = route.verb.lowerCased() + endpoint
            params = Object.array()
            pathComponents = @_extractPathComponents(route)
            if not pathComponents.isEmpty(): params.addAll(pathComponents)
            if clientTask.query: params.addAll(clientTask.query)
            if route.verb in ["POST", "PUT"]: params.append("body")
            for i in clientTask.payloadVerification.len().times():
                params.(i) = params.(i) + " is " + ClassCode(clientTask.payloadVerification.(i)).name
            end
            if clientTask.headers: params.addAll(clientTask.headers.map(def h: "\(h) is String"))
            params.append("success is Function")
            params.append("error is Function")
            composer = FunctionComposer(name, params)

            url = String.builder().add("SimiSync.baseUrl + \"").add(route.endpoint).add("\"")
            for path in pathComponents:
                url.add(".replacing(\"$").add(path).add("\", ").add(path).add(")")
            end
            if clientTask.query:
                url.add(" + \"?")
                for q in clientTask.query:
                    url.add(q).add("=").add("\"+").add(q).add("+\"&")
                end
                url.add("\"")
            end
            composer.line("url = " + url.build())
            headers = Object.array()
            for header in clientTask.headers:
                headers.append(header + "=" + header)
            end
            headersString = "[" + String.from(headers, ", ") + "]"

            successCodes = clientTask.successCodes ?? [200]
            successCodesString = ivic successCodes
            composer.line("Net.\(route.verb.lowerCased())([url = url, json = ivic body, headers = \(headersString)], def response:")
            composer.line("   if response.code in \(successCodesString.substring(0, successCodesString.len() - 1)): success(response)")
            composer.line("   else: error(response)")
            composer.line("end)")
            return composer.getString()
        end

        def _extractPathComponents(route): return route.endpoint.split('/')\
            .where(def p: p.startsWith('$'))\
            .map(def p: p.substring(1))
    end
end
